<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Editor de di√°logos - Autocompletado</title>
  <style>
    :root{
      --bg:#f6f7fb;
      --card:#ffffff;
      --accent:#6c63ff;
      --muted:#888;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:Inter,Segoe UI,Roboto,Arial,sans-serif;
      background:var(--bg);
      padding:28px;
      display:flex;
      justify-content:center;
    }

    .wrap{
      width:920px;
      max-width:96vw;
      background:var(--card);
      border-radius:10px;
      box-shadow:0 6px 20px rgba(15,15,30,.08);
      padding:20px;
    }

    h1{margin:0 0 12px 0; font-size:20px}
    .row{display:flex; gap:12px; align-items:center; margin-bottom:12px}
    .col{flex:1}

    input[type="text"]{
      width:100%;
      padding:10px 12px;
      border-radius:8px;
      border:1px solid #ddd;
      font-size:15px;
    }
    button{
      background:var(--accent);
      color:white;
      border:none;
      padding:10px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
    }
    button.ghost{
      background:transparent;
      color:var(--accent);
      border:1px solid var(--accent);
    }

    /* character tags */
    #charList{min-height:40px; display:flex; gap:8px; flex-wrap:wrap; align-items:center}
    .tag{
      background:#f0f3ff;
      color:#2a2a6b;
      padding:6px 10px;
      border-radius:999px;
      cursor:pointer;
      font-weight:600;
      user-select:none;
      border:1px solid rgba(108,99,255,.12);
    }
    .tag:hover{transform:translateY(-2px)}

    /* textarea & suggestions */
    textarea{
      width:100%;
      min-height:140px;
      padding:12px;
      border-radius:10px;
      border:1px solid #ddd;
      resize:vertical;
      font-size:15px;
      font-family:inherit;
    }

    .suggestions{
      border:1px solid #ddd;
      background:white;
      border-radius:8px;
      margin-top:8px;
      max-height:160px;
      overflow:auto;
      box-shadow:0 8px 20px rgba(10,10,30,.06);
    }
    .sug-item{
      padding:8px 10px;
      cursor:pointer;
      border-bottom:1px solid #f3f3f3;
      font-weight:600;
    }
    .sug-item:hover{background:#f6f7ff}

    /* dialogues list */
    #dialogueList{margin-top:12px; padding-left:18px}
    .dlg{margin:6px 0; padding:8px 10px; border-radius:8px; background:#fcfcff; border:1px solid #f1f1f6}
    .dlg b{display:block; margin-bottom:4px}
    .controls{display:flex; gap:8px; margin-top:12px; flex-wrap:wrap}
    .muted{color:var(--muted); font-size:13px;}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Editor de di√°logos</h1>

    <!-- Add character -->
    <div class="row">
      <div class="col">
        <input id="charInput" type="text" placeholder="Nombre personaje (ej: Fluff)" />
      </div>
      <div>
        <button id="addCharBtn">+ Agregar personaje</button>
      </div>
    </div>

    <!-- Character tags -->
    <div id="charList" class="muted">Sin personajes. Agrega uno arriba.</div>

    <hr style="margin:18px 0">

    <!-- textarea for dialogue input -->
    <div>
      <textarea id="dialogInput" placeholder="Escribe aqu√≠. Formato: Nombre: Texto. Puedes tener varias l√≠neas."></textarea>

      <!-- suggestions (autocompletion while typing) -->
      <div id="suggestions" class="suggestions" style="display:none;"></div>

      <div class="controls">
        <button id="addDialogBtn">+ Agregar di√°logos</button>
        <button id="exportBtn" class="ghost">üì• Exportar JSON</button>
        <div style="flex:1"></div>
        <div class="muted">Tip: click en una etiqueta para insertar <code>Nombre: </code> en el cursor.</div>
      </div>
    </div>

    <h2 style="margin-top:18px">Di√°logos</h2>
    <div id="dialogueList" class="muted">A√∫n no hay di√°logos.</div>
  </div>

  <script>
    /* === Datos === */
    let characters = [];
    let dialogues = [];

    /* === Helpers DOM === */
    const charInput = document.getElementById('charInput');
    const addCharBtn = document.getElementById('addCharBtn');
    const charList = document.getElementById('charList');

    const dialogInput = document.getElementById('dialogInput');
    const suggestionsBox = document.getElementById('suggestions');

    const addDialogBtn = document.getElementById('addDialogBtn');
    const dialogueList = document.getElementById('dialogueList');
    const exportBtn = document.getElementById('exportBtn');

    /* === Funciones b√°sicas === */

    function addCharacter(){
      const name = charInput.value.trim();
      if(!name) return;
      if(!characters.includes(name)){
        characters.push(name);
        renderCharacters();
      }
      charInput.value = '';
      charInput.focus();
    }

    function renderCharacters(){
      if(characters.length === 0){
        charList.innerHTML = '<span class="muted">Sin personajes. Agrega uno arriba.</span>';
        return;
      }
      charList.innerHTML = characters.map(c => `<div class="tag" data-name="${escapeHTML(c)}">${escapeHTML(c)}</div>`).join(' ');
      // agregar click a cada tag (inserta "Name: " en la posici√≥n del cursor)
      document.querySelectorAll('.tag').forEach(el => {
        el.addEventListener('click', e=>{
          const name = el.getAttribute('data-name');
          insertOrReplaceTokenAtCurrentLine(name + ': ');
          dialogInput.focus();
          updateSuggestions(); // actualizar
        });
      });
      // tambi√©n alimentar suggestions en caso que quieras usar datalist elsewhere
    }

    function escapeHTML(str){
      return String(str).replace(/[&<>"']/g, s=>({
        '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
      })[s]);
    }

    /* Insertar/reemplazar token en la linea actual del textarea:
       Si usuario est√° escribiendo el primer token de la l√≠nea, lo reemplaza.
       Si no hay token (linea vac√≠a o cursor al final), inserta en cursor. */
    function insertOrReplaceTokenAtCurrentLine(replacement){
      const ta = dialogInput;
      const val = ta.value;
      const pos = ta.selectionStart;
      // calcular inicio de la l√≠nea
      const lineStart = val.lastIndexOf('\n', pos - 1) + 1;
      const upToCursor = val.slice(lineStart, pos);
      const tokenMatch = upToCursor.match(/^([^\s:]+)/); // primer "palabra" de la linea
      if(tokenMatch){
        const token = tokenMatch[1];
        const tokenStart = lineStart;
        const tokenEnd = tokenStart + token.length;
        const newVal = val.slice(0, tokenStart) + replacement + val.slice(tokenEnd);
        ta.value = newVal;
        // colocar cursor justo despu√©s del replacement
        const newPos = tokenStart + replacement.length;
        setTimeout(()=>{ ta.setSelectionRange(newPos, newPos); }, 0);
      } else {
        // insertar en cursor
        const newVal = val.slice(0, pos) + replacement + val.slice(pos);
        ta.value = newVal;
        const newPos = pos + replacement.length;
        setTimeout(()=>{ ta.setSelectionRange(newPos, newPos); }, 0);
      }
      // disparar evento para suggestions
      updateSuggestions();
    }

    /* Insert at cursor helper (not used now but handy) */
    function insertAtCursor(insertText){
      const ta = dialogInput;
      const pos = ta.selectionStart;
      const val = ta.value;
      ta.value = val.slice(0,pos) + insertText + val.slice(pos);
      const newPos = pos + insertText.length;
      setTimeout(()=>{ ta.setSelectionRange(newPos,newPos); }, 0);
    }

    /* === Autocompletion while typing in textarea === */

    function updateSuggestions(){
      const ta = dialogInput;
      const pos = ta.selectionStart;
      const val = ta.value;
      // find start of current line
      const lineStart = val.lastIndexOf('\n', pos - 1) + 1;
      const lineToCursor = val.slice(lineStart, pos); // content from start of line to cursor
      // we only want to suggest if user is typing the first token (before any ":" or whitespace)
      const colonIndex = lineToCursor.indexOf(':');
      if(colonIndex !== -1){
        hideSuggestions();
        return; // ya puso ":" ‚Üí no sugerencias
      }
      // token is first word up to whitespace
      const match = lineToCursor.match(/^([^\s:]+)/);
      if(!match){ hideSuggestions(); return; }
      const token = match[1].toLowerCase();
      if(token.length === 0){ hideSuggestions(); return; }

      // filter character names starting with token (case-insensitive)
      const filtered = characters.filter(c => c.toLowerCase().startsWith(token));
      if(filtered.length === 0){ hideSuggestions(); return; }

      // render suggestions
      suggestionsBox.innerHTML = filtered.map(c => `<div class="sug-item" data-name="${escapeHTML(c)}">${escapeHTML(c)}</div>`).join('');
      suggestionsBox.style.display = 'block';
      // add click handlers
      suggestionsBox.querySelectorAll('.sug-item').forEach(el=>{
        el.addEventListener('click', ()=>{
          const name = el.getAttribute('data-name');
          // replace token at current line with selected name + ': '
          const ta = dialogInput;
          const pos2 = ta.selectionStart;
          const value2 = ta.value;
          const lineStart2 = value2.lastIndexOf('\n', pos2 - 1) + 1;
          const upToCursor2 = value2.slice(lineStart2, pos2);
          const tokenMatch2 = upToCursor2.match(/^([^\s:]+)/);
          if(tokenMatch2){
            const token = tokenMatch2[1];
            const tokenStart = lineStart2;
            const tokenEnd = tokenStart + token.length;
            const newVal = value2.slice(0, tokenStart) + name + ': ' + value2.slice(tokenEnd);
            ta.value = newVal;
            const newPos = tokenStart + name.length + 2;
            setTimeout(()=>{ ta.setSelectionRange(newPos,newPos); }, 0);
          } else {
            insertAtCursor(name + ': ');
          }
          hideSuggestions();
          ta.focus();
        });
      });
    }

    function hideSuggestions(){
      suggestionsBox.style.display = 'none';
      suggestionsBox.innerHTML = '';
    }

    /* update suggestions when typing */
    dialogInput.addEventListener('input', updateSuggestions);
    // hide suggestions on blur (small delay to allow click)
    dialogInput.addEventListener('blur', ()=> setTimeout(hideSuggestions, 120));
    dialogInput.addEventListener('keydown', (e)=>{
      if(e.key === 'Escape') hideSuggestions();
    });

    /* === Parsing texto -> di√°logos ===
       Reglas:
       - Para cada l√≠nea separada por salto de l√≠nea:
         - Si contiene "Nombre: texto..." se toma Nombre y el resto
         - Reemplaza comillas dobles (incluyendo curly ‚Äú ‚Äù) por simples '
         - Reemplaza '...' (3 o m√°s puntos) por el caracter de elipsis '‚Ä¶'
         - Divide el texto por '.' (punto) y cada fragmento no vac√≠o se agrega como di√°logo con '.' a√±adido.
       - Si una l√≠nea no tiene ':' se ignora.
    */
    function processTextareaToDialogues(){
      const raw = dialogInput.value;
      if(!raw.trim()) return;

      // normalize endings
      const lines = raw.split(/\r?\n/);
      let added = 0;
      lines.forEach(line => {
        const trimmed = line.trim();
        if(!trimmed) return;
        const colonIndex = trimmed.indexOf(':');
        if(colonIndex === -1) return; // no es una entrada "Name: ..."

        const name = trimmed.slice(0, colonIndex).trim();
        let msg = trimmed.slice(colonIndex + 1).trim();
        if(!msg) return;

        // replace curly quotes and normal double quotes with single quote
        msg = msg.replace(/["‚Äú‚Äù]/g, "'");

        // replace three or more dots with ellipsis char
        msg = msg.replace(/\.{3,}/g, '‚Ä¶');

        // split by '.' (period). Keep each sentence and add back '.'
        // we treat '‚Ä¶' as a single character (ellipses) and won't split on it.
        const fragments = msg.split('.');
        fragments.forEach(f => {
          const ftrim = f.trim();
          if(ftrim.length > 0){
            const finalText = ftrim + '.';
            dialogues.push({ character: name, text: finalText });
            added++;
          }
        });
      });

      if(added > 0){
        renderDialogues();
      }
      dialogInput.value = '';
      hideSuggestions();
    }

    /* Render dialogues */
    function renderDialogues(){
      if(dialogues.length === 0){
        dialogueList.innerHTML = '<span class="muted">A√∫n no hay di√°logos.</span>';
        return;
      }
      dialogueList.innerHTML = dialogues.map((d, idx) => {
        return `<div class="dlg"><b>${escapeHTML(d.character)}</b><div>${escapeHTML(d.text)}</div></div>`;
      }).join('');
    }

    /* Export JSON file */
    function exportJSON(){
      const data = { dialogue: dialogues };
      const json = JSON.stringify(data, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      // pedir nombre al usuario (opcional), si no, usar dialogo.json
      const name = prompt('Nombre del archivo (sin extensi√≥n):', 'dialogo') || 'dialogo';
      a.download = name + '.json';
      a.click();
      URL.revokeObjectURL(url);
    }

    /* === Eventos UI === */
    addCharBtn.addEventListener('click', addCharacter);
    charInput.addEventListener('keydown', (e)=> { if(e.key === 'Enter'){ addCharacter(); } });

    addDialogBtn.addEventListener('click', processTextareaToDialogues);
    exportBtn.addEventListener('click', exportJSON);

    // inicial: ejemplo (opcional)
    // characters = ['Z','Fluff','Edwar','Adler'];
    // renderCharacters();

    // render initial
    renderCharacters();
    renderDialogues();
  </script>
</body>
</html>